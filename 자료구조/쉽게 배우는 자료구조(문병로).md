# 목차
[0. 자료구조 소개](#0-자료구조-소개)<br>
[1. 재귀(자기호출)와 귀납적사고](#1-재귀(자기호출)와-귀납적사고)<br>
[2. 알고리즘의 성능](#2-알고리즘의-성능)<br>
[3. 리스트](#3-리스트)<br>
[4. 스택](#4-스택)<br>
[5. 큐](#5-큐)<br>
[6. 우선순위 큐 힙](#6-우선순위-큐-힙)<br>
[7. 정렬](#7-정렬)<br>
[8. 색인과 이진 검색 트리](#8-색인과-이진-검색-트리)<br>
[9. 균형 검색 트리](#9-균형-검색-트리)<br>
[10. 해시 테이블](#10-해시-테이블)<br>
[11. 그래프](#11-그래프)<br>
<br><br>


# 0. 자료구조 소개
자료를 효울적으로 접근하고 수정할 수 있도록 저장, 조직, 관리 하는 방법에 관한 이론<br>

<img src= "https://user-images.githubusercontent.com/117712307/200768279-e4edbcb5-856c-49e8-86ea-b6a499e1b7f7.jpeg" width="700" height="400"/>
<br><br>
리스트, 스택, 큐
<br> : 선형 자료구조 (데이터가 한 줄로 배치된 구조)<br>
<br>      
검색 트리, 해시 테이블 
<br>: 색인 자료구조 (데이터를 효율적으로 찾기 위한 구조)<br>       
<br>
힙(우선순위 큐: 힙) 
<br>: 우선순위 다루는 유용한 구조<br>        
<br>
그래프
<br>
: 관계 처리 자료구조                  

<br>

##  ㅇ 추상 데이터 타입 ADT
***

* 자바에서 8가지 기초 데이터 타입을 제외한 나머지는 추상 데이터 타입.<br>
* 대략 1ADT = 1Class, 1:1 대응
* 하나의 ADT 아래 여러 ADT 포함 가능
* 클래스 상위 개념인 인터페이스가 ADT에 잘 대응되는 개념
* '어떻게' 보다는 '무엇을' 하는지 신경 쓰게 해준다

<br>

# 1. 재귀(자기호출)와 귀납적사고
## 재귀 구조의 예
```
수열(재귀 버전)

fib(n) :
    if(n=1 or n=2)
        return 1
    else
        return fib(n-1) + fib(n-2)

** 위 예제는 재귀 알고리즘의 치명적인 예, 계산하는데 시간이 많이 걸린다.
   (한번 계산해놓은 결과를 계속 호출하여 지수함수적인 중복 발생)

수열(비재귀 버전)

fib_fast(n) :
    f[1] <- f[2] <- 1
    for i <- 3 to n

    f[i] <- f[i-1] + f[i-2]
    return f[n]

** 적재적소에 재귀 사용할 것
```
<br>
수열, 하노이 탑, 선택 정렬, (중위, 전위, 후위 표현법)'연산자위치' , 깊이 우선 탐색(DFS, Depth-frist Search)

<br>

## 깊이 우선 탐색
<img src= "https://user-images.githubusercontent.com/117712307/200831197-7b891bab-2bab-4535-a519-33e8aedadc38.jpeg" width="800" height="400"/><br>
0->2->4->1->4->7->4->2->0->3->5->3->0->끝<br>
<br>

## 재귀 알고리즘 필수 구성요소
* 경계 조건(종료 조건)
* 재귀 호출
* 관계 (하위 문제들과 본 문제의 관계를 나타내는 부분)

<br>

# 2. 알고리즘의 성능
## 알고리즘 복잡도
* 점근적 표기를 사용 ( 입력의 크기가 충분히 클 때의 복잡도. 작으면 수행 시간 별 차이없음)
* O(빅오) : 점근적 상한
* Ω(오메가) : 점근적 하한
* Θ(세타) : 점근적 동일

(1) O-표기(빅오)        
* O(n²)는 최고차항의 차수가 n²를 넘지않는 모든 함수의 집합을 뜻함
* 알고리즘이 어떤 입력에 대해, n²에 비례하는 시간을 초과하지 않는다면 이 알고리즘의 수행시간은 O(n²)라고 한다.
* n²는 2차함수를 총칭, (n², 3n²-2n, 8n²+7nlogn 등), *2차 함수 미만도 포함 
* nlogn + 5n은 O(n²)에도 포함되고 O(nlogn)에도 속한다. O(n²)으로 표현해도 상관 없지만, 이 경우 정보 손실이 생감.

(2) Ω-표기(오메가)      
* Ω(n²)는 O(n²)과 정반대.
* Ω(n²)는 최고차항의 차수가 n²를 넘는 모든 함수의 집합(n^3, 10n^100, ...)
* 7n^3-100n의 경우 Ω(n²)에도 속하고 Ω(n^3)에도 속한다. Ω(n²)이라고 표현할 경우 정보 손실 생기니, 가능한 정확히 표기

(3) Θ-표기(세타)
* Θ(n^2)는 최고차항의 차수가 정확히 n^2인 모든 함수의 집합을 뜻함 
* 7n^2-5n-8, 3n^2+31n+100, ...
* 세타는 빅오와 오메가의 교집합
* Θ(n^3)은 한상 n^3에 비례하는 시간이 든다는 뜻

(4) 이 페이지에서는 ∈ 를 = 로 표기
* 알고리즘 수행 시간은 흔히 T(n)으로 표기
* n^2에 비례한다면 T(n^2) ∈ O(n^2)
* 번거롭기 떄문에  T(n^2) = O(n^2) 라고 바꿔 쓸것
* 앞 기호가 뒷 기호에 포함되는 것을 표한하는 것이기 떄문에 순서 바꿔 쓰지 말것.

(5) 자주 사용하는 O- 표기
* O(1) - 상수 시간      
    * O(1)는 일정한 복잡도(constant complexity)라고 하며, 입력값이 증가하더라도 시간이 늘어나지 않는다.
* O(logn) - 로그(대수) 시간
* O(n) - 선형 시간
* O(nlogn) - 로그 선형 시간
* O(n^2) - 이차 시간
* O(n^3) - 3차 시간
* O(2^n) - 지수 시간        
<br>
(빅오)      
![image](https://user-images.githubusercontent.com/117712307/201835951-0f4207c9-3e63-4c88-a755-f671a278a799.png)

(6) 주로 사용하는 기호
* 시간복잡도는 알고리즘에서 보통 일반적으로 O-표기를 사용.

<br>

# 3. 리스트
## 1. 배열을 이용한 리스트
* 시작 위치부터 빈자리 없이 자료를 순서대로 저장
* 단순하고 효율성이 높음, 리스트 필요 공간 예측이 힘들어 공간 낭비가 심함
* 원소를 삽입하거나 삭제를 해도 빈자리 없이 자료가 순서대로 연속 저장

1. 배열 리스트의 작업       
    * 원소 삽입하려면 어디에 넣을지에 관한 정보도 필요함
    * item[] a = new item[]{10, 20, 30, 40, 50, 60, 70} - > add(3,35) -> {10, 20, 30, ```35```, 40, 50, 60, 70}
    


## 2. 연결을 이용한 리스트
* 물리적 위치나 순서에 상관없이 링크에 의해 논리적인 순서를 표현
* 공간 낭비 피할 수 있음, 원소가 추가 될 때마다 공간을 할당받아 추가하는 동적 할당 방식
* 접근은 첫 번째 노드부터
* 연결 리스트 객체는 직접 저장할 필요가 없고 리스트의 첫 번쨰 노드에 접근 할 수 있는 레퍼런스만 갖고 있으면 된다.
* 첫 번쨰 노드에 대한 레퍼런스 필드(head)를 가지고있음

1. 연결 리스트의 작업
    * 중간에 삽입 하려면 삽입 노드의 바로 앞 노드를 가리키는 레퍼런스가 있어야 한다.
    ```
    newNode.item <- x
    newNode.next <- prevNode.next
    prevNode.next <- newNode
    numItems++
    ```
    * 맨 앞에 원소를 삽입할 때는 중간노드가 없기 때문에 head값을 수정한다.
    ```
    newNode.item <- x
    newNode.next <- prevNode.next
    prevNode.next <- newNode
    numItems++
    ```

## 3. 배열, 연결 리스트 비교
* 배열 -> 시작부터 고정된 크기 지정, 연결 -> 들어오는 대로 공간 할당
* 배열 : 정적, 연결 : 동적
* 배열은 원하는 값을 찾을 때 바로 그 값에 접근 가능, 연결은 헤드노드 부터 원하는 값까지 순차적으로 접근
* (원소들은 배열, 연결 둘다 규칙 없이 리스트에 저장되어있음), 원소 x를 검색하는데 평균 Θ(n)의 시간이 든다, 최악의 경우 배열:Θ(logn), 연결:Θ(n)의 검색 시간이 든다.

## 4. 원형 연결 리스트
* 연결 리스트 첫 노드와 마지막 노드에 대한 접근성이 극적으로 차이남
* 원소 수가 n이라면 맨 앞을 삽입/삭제 시 Θ(1)의 시간이 드는 반면, 마지막은 Θ(n)의 시간이 듬
* 마지막 노드가 첫 번쨰 노드를 링크해서 해결.

## 5. 양방향 연결 리스트
* 처음 노드가 마지막 노드를, 마지막 노드가 처음 노드를 가리키는 구조
* 기존 next 만 가지고 있던 구조와 다르게 prev 추가해서 양방향으로 구현

<br>

# 4. 스택
가장 먼저 들어온 데이터가 가장 먼저 나감, LIFO(last in first out)
## 1. 개념 
<img src= "https://user-images.githubusercontent.com/117712307/202105926-a52797eb-e004-4e1a-add9-6188bf5c011c.jpeg" width="700" height="400"/>


<br>

# 5. 큐
<br>

# 6. 우선순위 큐 힙
<br>

# 7. 정렬
<br>

# 8. 색인과 이진 검색 트리
<br>

# 9. 균형 검색 트리
<br>

# 10. 해시 테이블
<br>

# 11. 그래프
<br>
